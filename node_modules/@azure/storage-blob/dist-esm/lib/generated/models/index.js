/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
/**
 * Defines values for PublicAccessType.
 * Possible values include: 'container', 'blob'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: PublicAccessType =
 * <PublicAccessType>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export var PublicAccessType;
(function (PublicAccessType) {
    PublicAccessType["Container"] = "container";
    PublicAccessType["Blob"] = "blob";
})(PublicAccessType || (PublicAccessType = {}));
/**
 * Defines values for CopyStatusType.
 * Possible values include: 'pending', 'success', 'aborted', 'failed'
 * @readonly
 * @enum {string}
 */
export var CopyStatusType;
(function (CopyStatusType) {
    CopyStatusType["Pending"] = "pending";
    CopyStatusType["Success"] = "success";
    CopyStatusType["Aborted"] = "aborted";
    CopyStatusType["Failed"] = "failed";
})(CopyStatusType || (CopyStatusType = {}));
/**
 * Defines values for LeaseDurationType.
 * Possible values include: 'infinite', 'fixed'
 * @readonly
 * @enum {string}
 */
export var LeaseDurationType;
(function (LeaseDurationType) {
    LeaseDurationType["Infinite"] = "infinite";
    LeaseDurationType["Fixed"] = "fixed";
})(LeaseDurationType || (LeaseDurationType = {}));
/**
 * Defines values for LeaseStateType.
 * Possible values include: 'available', 'leased', 'expired', 'breaking',
 * 'broken'
 * @readonly
 * @enum {string}
 */
export var LeaseStateType;
(function (LeaseStateType) {
    LeaseStateType["Available"] = "available";
    LeaseStateType["Leased"] = "leased";
    LeaseStateType["Expired"] = "expired";
    LeaseStateType["Breaking"] = "breaking";
    LeaseStateType["Broken"] = "broken";
})(LeaseStateType || (LeaseStateType = {}));
/**
 * Defines values for LeaseStatusType.
 * Possible values include: 'locked', 'unlocked'
 * @readonly
 * @enum {string}
 */
export var LeaseStatusType;
(function (LeaseStatusType) {
    LeaseStatusType["Locked"] = "locked";
    LeaseStatusType["Unlocked"] = "unlocked";
})(LeaseStatusType || (LeaseStatusType = {}));
/**
 * Defines values for AccessTier.
 * Possible values include: 'P4', 'P6', 'P10', 'P20', 'P30', 'P40', 'P50',
 * 'Hot', 'Cool', 'Archive'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: AccessTier = <AccessTier>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export var AccessTier;
(function (AccessTier) {
    AccessTier["P4"] = "P4";
    AccessTier["P6"] = "P6";
    AccessTier["P10"] = "P10";
    AccessTier["P20"] = "P20";
    AccessTier["P30"] = "P30";
    AccessTier["P40"] = "P40";
    AccessTier["P50"] = "P50";
    AccessTier["Hot"] = "Hot";
    AccessTier["Cool"] = "Cool";
    AccessTier["Archive"] = "Archive";
})(AccessTier || (AccessTier = {}));
/**
 * Defines values for ArchiveStatus.
 * Possible values include: 'rehydrate-pending-to-hot',
 * 'rehydrate-pending-to-cool'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: ArchiveStatus =
 * <ArchiveStatus>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export var ArchiveStatus;
(function (ArchiveStatus) {
    ArchiveStatus["RehydratePendingToHot"] = "rehydrate-pending-to-hot";
    ArchiveStatus["RehydratePendingToCool"] = "rehydrate-pending-to-cool";
})(ArchiveStatus || (ArchiveStatus = {}));
/**
 * Defines values for BlobType.
 * Possible values include: 'BlockBlob', 'PageBlob', 'AppendBlob'
 * @readonly
 * @enum {string}
 */
export var BlobType;
(function (BlobType) {
    BlobType["BlockBlob"] = "BlockBlob";
    BlobType["PageBlob"] = "PageBlob";
    BlobType["AppendBlob"] = "AppendBlob";
})(BlobType || (BlobType = {}));
/**
 * Defines values for StorageErrorCode.
 * Possible values include: 'AccountAlreadyExists', 'AccountBeingCreated',
 * 'AccountIsDisabled', 'AuthenticationFailed', 'ConditionHeadersNotSupported',
 * 'ConditionNotMet', 'EmptyMetadataKey', 'InsufficientAccountPermissions',
 * 'InternalError', 'InvalidAuthenticationInfo', 'InvalidHeaderValue',
 * 'InvalidHttpVerb', 'InvalidInput', 'InvalidMd5', 'InvalidMetadata',
 * 'InvalidQueryParameterValue', 'InvalidRange', 'InvalidResourceName',
 * 'InvalidUri', 'InvalidXmlDocument', 'InvalidXmlNodeValue', 'Md5Mismatch',
 * 'MetadataTooLarge', 'MissingContentLengthHeader',
 * 'MissingRequiredQueryParameter', 'MissingRequiredHeader',
 * 'MissingRequiredXmlNode', 'MultipleConditionHeadersNotSupported',
 * 'OperationTimedOut', 'OutOfRangeInput', 'OutOfRangeQueryParameterValue',
 * 'RequestBodyTooLarge', 'ResourceTypeMismatch', 'RequestUrlFailedToParse',
 * 'ResourceAlreadyExists', 'ResourceNotFound', 'ServerBusy',
 * 'UnsupportedHeader', 'UnsupportedXmlNode', 'UnsupportedQueryParameter',
 * 'UnsupportedHttpVerb', 'AppendPositionConditionNotMet', 'BlobAlreadyExists',
 * 'BlobNotFound', 'BlobOverwritten', 'BlobTierInadequateForContentLength',
 * 'BlockCountExceedsLimit', 'BlockListTooLong', 'CannotChangeToLowerTier',
 * 'CannotVerifyCopySource', 'ContainerAlreadyExists', 'ContainerBeingDeleted',
 * 'ContainerDisabled', 'ContainerNotFound',
 * 'ContentLengthLargerThanTierLimit', 'CopyAcrossAccountsNotSupported',
 * 'CopyIdMismatch', 'FeatureVersionMismatch', 'IncrementalCopyBlobMismatch',
 * 'IncrementalCopyOfEralierVersionSnapshotNotAllowed',
 * 'IncrementalCopySourceMustBeSnapshot', 'InfiniteLeaseDurationRequired',
 * 'InvalidBlobOrBlock', 'InvalidBlobTier', 'InvalidBlobType',
 * 'InvalidBlockId', 'InvalidBlockList', 'InvalidOperation',
 * 'InvalidPageRange', 'InvalidSourceBlobType', 'InvalidSourceBlobUrl',
 * 'InvalidVersionForPageBlobOperation', 'LeaseAlreadyPresent',
 * 'LeaseAlreadyBroken', 'LeaseIdMismatchWithBlobOperation',
 * 'LeaseIdMismatchWithContainerOperation',
 * 'LeaseIdMismatchWithLeaseOperation', 'LeaseIdMissing',
 * 'LeaseIsBreakingAndCannotBeAcquired', 'LeaseIsBreakingAndCannotBeChanged',
 * 'LeaseIsBrokenAndCannotBeRenewed', 'LeaseLost',
 * 'LeaseNotPresentWithBlobOperation', 'LeaseNotPresentWithContainerOperation',
 * 'LeaseNotPresentWithLeaseOperation', 'MaxBlobSizeConditionNotMet',
 * 'NoPendingCopyOperation', 'OperationNotAllowedOnIncrementalCopyBlob',
 * 'PendingCopyOperation', 'PreviousSnapshotCannotBeNewer',
 * 'PreviousSnapshotNotFound', 'PreviousSnapshotOperationNotSupported',
 * 'SequenceNumberConditionNotMet', 'SequenceNumberIncrementTooLarge',
 * 'SnapshotCountExceeded', 'SnaphotOperationRateExceeded', 'SnapshotsPresent',
 * 'SourceConditionNotMet', 'SystemInUse', 'TargetConditionNotMet',
 * 'UnauthorizedBlobOverwrite', 'BlobBeingRehydrated', 'BlobArchived',
 * 'BlobNotArchived'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: StorageErrorCode =
 * <StorageErrorCode>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export var StorageErrorCode;
(function (StorageErrorCode) {
    StorageErrorCode["AccountAlreadyExists"] = "AccountAlreadyExists";
    StorageErrorCode["AccountBeingCreated"] = "AccountBeingCreated";
    StorageErrorCode["AccountIsDisabled"] = "AccountIsDisabled";
    StorageErrorCode["AuthenticationFailed"] = "AuthenticationFailed";
    StorageErrorCode["ConditionHeadersNotSupported"] = "ConditionHeadersNotSupported";
    StorageErrorCode["ConditionNotMet"] = "ConditionNotMet";
    StorageErrorCode["EmptyMetadataKey"] = "EmptyMetadataKey";
    StorageErrorCode["InsufficientAccountPermissions"] = "InsufficientAccountPermissions";
    StorageErrorCode["InternalError"] = "InternalError";
    StorageErrorCode["InvalidAuthenticationInfo"] = "InvalidAuthenticationInfo";
    StorageErrorCode["InvalidHeaderValue"] = "InvalidHeaderValue";
    StorageErrorCode["InvalidHttpVerb"] = "InvalidHttpVerb";
    StorageErrorCode["InvalidInput"] = "InvalidInput";
    StorageErrorCode["InvalidMd5"] = "InvalidMd5";
    StorageErrorCode["InvalidMetadata"] = "InvalidMetadata";
    StorageErrorCode["InvalidQueryParameterValue"] = "InvalidQueryParameterValue";
    StorageErrorCode["InvalidRange"] = "InvalidRange";
    StorageErrorCode["InvalidResourceName"] = "InvalidResourceName";
    StorageErrorCode["InvalidUri"] = "InvalidUri";
    StorageErrorCode["InvalidXmlDocument"] = "InvalidXmlDocument";
    StorageErrorCode["InvalidXmlNodeValue"] = "InvalidXmlNodeValue";
    StorageErrorCode["Md5Mismatch"] = "Md5Mismatch";
    StorageErrorCode["MetadataTooLarge"] = "MetadataTooLarge";
    StorageErrorCode["MissingContentLengthHeader"] = "MissingContentLengthHeader";
    StorageErrorCode["MissingRequiredQueryParameter"] = "MissingRequiredQueryParameter";
    StorageErrorCode["MissingRequiredHeader"] = "MissingRequiredHeader";
    StorageErrorCode["MissingRequiredXmlNode"] = "MissingRequiredXmlNode";
    StorageErrorCode["MultipleConditionHeadersNotSupported"] = "MultipleConditionHeadersNotSupported";
    StorageErrorCode["OperationTimedOut"] = "OperationTimedOut";
    StorageErrorCode["OutOfRangeInput"] = "OutOfRangeInput";
    StorageErrorCode["OutOfRangeQueryParameterValue"] = "OutOfRangeQueryParameterValue";
    StorageErrorCode["RequestBodyTooLarge"] = "RequestBodyTooLarge";
    StorageErrorCode["ResourceTypeMismatch"] = "ResourceTypeMismatch";
    StorageErrorCode["RequestUrlFailedToParse"] = "RequestUrlFailedToParse";
    StorageErrorCode["ResourceAlreadyExists"] = "ResourceAlreadyExists";
    StorageErrorCode["ResourceNotFound"] = "ResourceNotFound";
    StorageErrorCode["ServerBusy"] = "ServerBusy";
    StorageErrorCode["UnsupportedHeader"] = "UnsupportedHeader";
    StorageErrorCode["UnsupportedXmlNode"] = "UnsupportedXmlNode";
    StorageErrorCode["UnsupportedQueryParameter"] = "UnsupportedQueryParameter";
    StorageErrorCode["UnsupportedHttpVerb"] = "UnsupportedHttpVerb";
    StorageErrorCode["AppendPositionConditionNotMet"] = "AppendPositionConditionNotMet";
    StorageErrorCode["BlobAlreadyExists"] = "BlobAlreadyExists";
    StorageErrorCode["BlobNotFound"] = "BlobNotFound";
    StorageErrorCode["BlobOverwritten"] = "BlobOverwritten";
    StorageErrorCode["BlobTierInadequateForContentLength"] = "BlobTierInadequateForContentLength";
    StorageErrorCode["BlockCountExceedsLimit"] = "BlockCountExceedsLimit";
    StorageErrorCode["BlockListTooLong"] = "BlockListTooLong";
    StorageErrorCode["CannotChangeToLowerTier"] = "CannotChangeToLowerTier";
    StorageErrorCode["CannotVerifyCopySource"] = "CannotVerifyCopySource";
    StorageErrorCode["ContainerAlreadyExists"] = "ContainerAlreadyExists";
    StorageErrorCode["ContainerBeingDeleted"] = "ContainerBeingDeleted";
    StorageErrorCode["ContainerDisabled"] = "ContainerDisabled";
    StorageErrorCode["ContainerNotFound"] = "ContainerNotFound";
    StorageErrorCode["ContentLengthLargerThanTierLimit"] = "ContentLengthLargerThanTierLimit";
    StorageErrorCode["CopyAcrossAccountsNotSupported"] = "CopyAcrossAccountsNotSupported";
    StorageErrorCode["CopyIdMismatch"] = "CopyIdMismatch";
    StorageErrorCode["FeatureVersionMismatch"] = "FeatureVersionMismatch";
    StorageErrorCode["IncrementalCopyBlobMismatch"] = "IncrementalCopyBlobMismatch";
    StorageErrorCode["IncrementalCopyOfEralierVersionSnapshotNotAllowed"] = "IncrementalCopyOfEralierVersionSnapshotNotAllowed";
    StorageErrorCode["IncrementalCopySourceMustBeSnapshot"] = "IncrementalCopySourceMustBeSnapshot";
    StorageErrorCode["InfiniteLeaseDurationRequired"] = "InfiniteLeaseDurationRequired";
    StorageErrorCode["InvalidBlobOrBlock"] = "InvalidBlobOrBlock";
    StorageErrorCode["InvalidBlobTier"] = "InvalidBlobTier";
    StorageErrorCode["InvalidBlobType"] = "InvalidBlobType";
    StorageErrorCode["InvalidBlockId"] = "InvalidBlockId";
    StorageErrorCode["InvalidBlockList"] = "InvalidBlockList";
    StorageErrorCode["InvalidOperation"] = "InvalidOperation";
    StorageErrorCode["InvalidPageRange"] = "InvalidPageRange";
    StorageErrorCode["InvalidSourceBlobType"] = "InvalidSourceBlobType";
    StorageErrorCode["InvalidSourceBlobUrl"] = "InvalidSourceBlobUrl";
    StorageErrorCode["InvalidVersionForPageBlobOperation"] = "InvalidVersionForPageBlobOperation";
    StorageErrorCode["LeaseAlreadyPresent"] = "LeaseAlreadyPresent";
    StorageErrorCode["LeaseAlreadyBroken"] = "LeaseAlreadyBroken";
    StorageErrorCode["LeaseIdMismatchWithBlobOperation"] = "LeaseIdMismatchWithBlobOperation";
    StorageErrorCode["LeaseIdMismatchWithContainerOperation"] = "LeaseIdMismatchWithContainerOperation";
    StorageErrorCode["LeaseIdMismatchWithLeaseOperation"] = "LeaseIdMismatchWithLeaseOperation";
    StorageErrorCode["LeaseIdMissing"] = "LeaseIdMissing";
    StorageErrorCode["LeaseIsBreakingAndCannotBeAcquired"] = "LeaseIsBreakingAndCannotBeAcquired";
    StorageErrorCode["LeaseIsBreakingAndCannotBeChanged"] = "LeaseIsBreakingAndCannotBeChanged";
    StorageErrorCode["LeaseIsBrokenAndCannotBeRenewed"] = "LeaseIsBrokenAndCannotBeRenewed";
    StorageErrorCode["LeaseLost"] = "LeaseLost";
    StorageErrorCode["LeaseNotPresentWithBlobOperation"] = "LeaseNotPresentWithBlobOperation";
    StorageErrorCode["LeaseNotPresentWithContainerOperation"] = "LeaseNotPresentWithContainerOperation";
    StorageErrorCode["LeaseNotPresentWithLeaseOperation"] = "LeaseNotPresentWithLeaseOperation";
    StorageErrorCode["MaxBlobSizeConditionNotMet"] = "MaxBlobSizeConditionNotMet";
    StorageErrorCode["NoPendingCopyOperation"] = "NoPendingCopyOperation";
    StorageErrorCode["OperationNotAllowedOnIncrementalCopyBlob"] = "OperationNotAllowedOnIncrementalCopyBlob";
    StorageErrorCode["PendingCopyOperation"] = "PendingCopyOperation";
    StorageErrorCode["PreviousSnapshotCannotBeNewer"] = "PreviousSnapshotCannotBeNewer";
    StorageErrorCode["PreviousSnapshotNotFound"] = "PreviousSnapshotNotFound";
    StorageErrorCode["PreviousSnapshotOperationNotSupported"] = "PreviousSnapshotOperationNotSupported";
    StorageErrorCode["SequenceNumberConditionNotMet"] = "SequenceNumberConditionNotMet";
    StorageErrorCode["SequenceNumberIncrementTooLarge"] = "SequenceNumberIncrementTooLarge";
    StorageErrorCode["SnapshotCountExceeded"] = "SnapshotCountExceeded";
    StorageErrorCode["SnaphotOperationRateExceeded"] = "SnaphotOperationRateExceeded";
    StorageErrorCode["SnapshotsPresent"] = "SnapshotsPresent";
    StorageErrorCode["SourceConditionNotMet"] = "SourceConditionNotMet";
    StorageErrorCode["SystemInUse"] = "SystemInUse";
    StorageErrorCode["TargetConditionNotMet"] = "TargetConditionNotMet";
    StorageErrorCode["UnauthorizedBlobOverwrite"] = "UnauthorizedBlobOverwrite";
    StorageErrorCode["BlobBeingRehydrated"] = "BlobBeingRehydrated";
    StorageErrorCode["BlobArchived"] = "BlobArchived";
    StorageErrorCode["BlobNotArchived"] = "BlobNotArchived";
})(StorageErrorCode || (StorageErrorCode = {}));
/**
 * Defines values for GeoReplicationStatusType.
 * Possible values include: 'live', 'bootstrap', 'unavailable'
 * There could be more values for this enum apart from the ones defined here.If
 * you want to set a value that is not from the known values then you can do
 * the following:
 * let param: GeoReplicationStatusType =
 * <GeoReplicationStatusType>"someUnknownValueThatWillStillBeValid";
 * @readonly
 * @enum {string}
 */
export var GeoReplicationStatusType;
(function (GeoReplicationStatusType) {
    GeoReplicationStatusType["Live"] = "live";
    GeoReplicationStatusType["Bootstrap"] = "bootstrap";
    GeoReplicationStatusType["Unavailable"] = "unavailable";
})(GeoReplicationStatusType || (GeoReplicationStatusType = {}));
/**
 * Defines values for BlockListType.
 * Possible values include: 'committed', 'uncommitted', 'all'
 * @readonly
 * @enum {string}
 */
export var BlockListType;
(function (BlockListType) {
    BlockListType["Committed"] = "committed";
    BlockListType["Uncommitted"] = "uncommitted";
    BlockListType["All"] = "all";
})(BlockListType || (BlockListType = {}));
/**
 * Defines values for DeleteSnapshotsOptionType.
 * Possible values include: 'include', 'only'
 * @readonly
 * @enum {string}
 */
export var DeleteSnapshotsOptionType;
(function (DeleteSnapshotsOptionType) {
    DeleteSnapshotsOptionType["Include"] = "include";
    DeleteSnapshotsOptionType["Only"] = "only";
})(DeleteSnapshotsOptionType || (DeleteSnapshotsOptionType = {}));
/**
 * Defines values for ListBlobsIncludeItem.
 * Possible values include: 'snapshots', 'metadata', 'uncommittedblobs',
 * 'copy', 'deleted'
 * @readonly
 * @enum {string}
 */
export var ListBlobsIncludeItem;
(function (ListBlobsIncludeItem) {
    ListBlobsIncludeItem["Snapshots"] = "snapshots";
    ListBlobsIncludeItem["Metadata"] = "metadata";
    ListBlobsIncludeItem["Uncommittedblobs"] = "uncommittedblobs";
    ListBlobsIncludeItem["Copy"] = "copy";
    ListBlobsIncludeItem["Deleted"] = "deleted";
})(ListBlobsIncludeItem || (ListBlobsIncludeItem = {}));
/**
 * Defines values for ListContainersIncludeType.
 * Possible values include: 'metadata'
 * @readonly
 * @enum {string}
 */
export var ListContainersIncludeType;
(function (ListContainersIncludeType) {
    ListContainersIncludeType["Metadata"] = "metadata";
})(ListContainersIncludeType || (ListContainersIncludeType = {}));
/**
 * Defines values for SequenceNumberActionType.
 * Possible values include: 'max', 'update', 'increment'
 * @readonly
 * @enum {string}
 */
export var SequenceNumberActionType;
(function (SequenceNumberActionType) {
    SequenceNumberActionType["Max"] = "max";
    SequenceNumberActionType["Update"] = "update";
    SequenceNumberActionType["Increment"] = "increment";
})(SequenceNumberActionType || (SequenceNumberActionType = {}));
/**
 * Defines values for SkuName.
 * Possible values include: 'Standard_LRS', 'Standard_GRS', 'Standard_RAGRS',
 * 'Standard_ZRS', 'Premium_LRS'
 * @readonly
 * @enum {string}
 */
export var SkuName;
(function (SkuName) {
    SkuName["StandardLRS"] = "Standard_LRS";
    SkuName["StandardGRS"] = "Standard_GRS";
    SkuName["StandardRAGRS"] = "Standard_RAGRS";
    SkuName["StandardZRS"] = "Standard_ZRS";
    SkuName["PremiumLRS"] = "Premium_LRS";
})(SkuName || (SkuName = {}));
/**
 * Defines values for AccountKind.
 * Possible values include: 'Storage', 'BlobStorage', 'StorageV2'
 * @readonly
 * @enum {string}
 */
export var AccountKind;
(function (AccountKind) {
    AccountKind["Storage"] = "Storage";
    AccountKind["BlobStorage"] = "BlobStorage";
    AccountKind["StorageV2"] = "StorageV2";
})(AccountKind || (AccountKind = {}));
//# sourceMappingURL=index.js.map