"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var operationSpec_1 = require("../operationSpec");
var restError_1 = require("../restError");
var serializer_1 = require("../serializer");
var utils = tslib_1.__importStar(require("../util/utils"));
var xml_1 = require("../util/xml");
var requestPolicy_1 = require("./requestPolicy");
/**
 * Create a new serialization RequestPolicyCreator that will serialized HTTP request bodies as they
 * pass through the HTTP pipeline.
 */
function deserializationPolicy() {
    return {
        create: function (nextPolicy, options) {
            return new DeserializationPolicy(nextPolicy, options);
        }
    };
}
exports.deserializationPolicy = deserializationPolicy;
/**
 * A RequestPolicy that will deserialize HTTP response bodies and headers as they pass through the
 * HTTP pipeline.
 */
var DeserializationPolicy = /** @class */ (function (_super) {
    tslib_1.__extends(DeserializationPolicy, _super);
    function DeserializationPolicy(nextPolicy, options) {
        return _super.call(this, nextPolicy, options) || this;
    }
    DeserializationPolicy.prototype.sendRequest = function (request) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._nextPolicy.sendRequest(request).then(deserializeResponseBody)];
            });
        });
    };
    return DeserializationPolicy;
}(requestPolicy_1.BaseRequestPolicy));
exports.DeserializationPolicy = DeserializationPolicy;
function getOperationResponse(parsedResponse) {
    var result;
    var request = parsedResponse.request;
    var operationSpec = request.operationSpec;
    if (operationSpec) {
        var operationResponseGetter = request.operationResponseGetter;
        if (!operationResponseGetter) {
            result = operationSpec.responses[parsedResponse.status];
        }
        else {
            result = operationResponseGetter(operationSpec, parsedResponse);
        }
    }
    return result;
}
function shouldDeserializeResponse(parsedResponse) {
    var shouldDeserialize = parsedResponse.request.shouldDeserialize;
    var result;
    if (shouldDeserialize === undefined) {
        result = true;
    }
    else if (typeof shouldDeserialize === "boolean") {
        result = shouldDeserialize;
    }
    else {
        result = shouldDeserialize(parsedResponse);
    }
    return result;
}
function deserializeResponseBody(response) {
    return parse(response).then(function (parsedResponse) {
        var shouldDeserialize = shouldDeserializeResponse(parsedResponse);
        if (shouldDeserialize) {
            var operationSpec = parsedResponse.request.operationSpec;
            if (operationSpec && operationSpec.responses) {
                var statusCode = parsedResponse.status;
                var expectedStatusCodes = Object.keys(operationSpec.responses);
                var hasNoExpectedStatusCodes = (expectedStatusCodes.length === 0 || (expectedStatusCodes.length === 1 && expectedStatusCodes[0] === "default"));
                var responseSpec = getOperationResponse(parsedResponse);
                var isExpectedStatusCode = hasNoExpectedStatusCodes ? (200 <= statusCode && statusCode < 300) : !!responseSpec;
                if (!isExpectedStatusCode) {
                    var defaultResponseSpec = operationSpec.responses.default;
                    if (defaultResponseSpec) {
                        var initialErrorMessage = operationSpec_1.isStreamOperation(operationSpec)
                            ? "Unexpected status code: " + statusCode
                            : parsedResponse.bodyAsText;
                        var error = new restError_1.RestError(initialErrorMessage);
                        error.statusCode = statusCode;
                        error.request = utils.stripRequest(parsedResponse.request);
                        error.response = utils.stripResponse(parsedResponse);
                        var parsedErrorResponse = parsedResponse.parsedBody;
                        try {
                            if (parsedErrorResponse) {
                                var defaultResponseBodyMapper = defaultResponseSpec.bodyMapper;
                                if (defaultResponseBodyMapper && defaultResponseBodyMapper.serializedName === "CloudError") {
                                    if (parsedErrorResponse.error) {
                                        parsedErrorResponse = parsedErrorResponse.error;
                                    }
                                    if (parsedErrorResponse.code) {
                                        error.code = parsedErrorResponse.code;
                                    }
                                    if (parsedErrorResponse.message) {
                                        error.message = parsedErrorResponse.message;
                                    }
                                }
                                else {
                                    var internalError = parsedErrorResponse;
                                    if (parsedErrorResponse.error) {
                                        internalError = parsedErrorResponse.error;
                                    }
                                    error.code = internalError.code;
                                    if (internalError.message) {
                                        error.message = internalError.message;
                                    }
                                }
                                if (defaultResponseBodyMapper) {
                                    var valueToDeserialize = parsedErrorResponse;
                                    if (operationSpec.isXML && defaultResponseBodyMapper.type.name === serializer_1.MapperType.Sequence) {
                                        valueToDeserialize = typeof parsedErrorResponse === "object"
                                            ? parsedErrorResponse[defaultResponseBodyMapper.xmlElementName]
                                            : [];
                                    }
                                    error.body = operationSpec.serializer.deserialize(defaultResponseBodyMapper, valueToDeserialize, "error.body");
                                }
                            }
                        }
                        catch (defaultError) {
                            error.message = "Error \"" + defaultError.message + "\" occurred in deserializing the responseBody - \"" + parsedResponse.bodyAsText + "\" for the default response.";
                        }
                        return Promise.reject(error);
                    }
                }
                else if (responseSpec) {
                    if (responseSpec.bodyMapper) {
                        var valueToDeserialize = parsedResponse.parsedBody;
                        if (operationSpec.isXML && responseSpec.bodyMapper.type.name === serializer_1.MapperType.Sequence) {
                            valueToDeserialize = typeof valueToDeserialize === "object" ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName] : [];
                        }
                        try {
                            parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, "operationRes.parsedBody");
                        }
                        catch (error) {
                            var restError = new restError_1.RestError("Error " + error + " occurred in deserializing the responseBody - " + parsedResponse.bodyAsText);
                            restError.request = utils.stripRequest(parsedResponse.request);
                            restError.response = utils.stripResponse(parsedResponse);
                            return Promise.reject(restError);
                        }
                    }
                    else if (operationSpec.httpMethod === "HEAD") {
                        // head methods never have a body, but we return a boolean to indicate presence/absence of the resource
                        parsedResponse.parsedBody = response.status >= 200 && response.status < 300;
                    }
                    if (responseSpec.headersMapper) {
                        parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.rawHeaders(), "operationRes.parsedHeaders");
                    }
                }
            }
        }
        return Promise.resolve(parsedResponse);
    });
}
exports.deserializeResponseBody = deserializeResponseBody;
function parse(operationResponse) {
    var errorHandler = function (err) {
        var msg = "Error \"" + err + "\" occurred while parsing the response body - " + operationResponse.bodyAsText + ".";
        var errCode = err.code || restError_1.RestError.PARSE_ERROR;
        var e = new restError_1.RestError(msg, errCode, operationResponse.status, operationResponse.request, operationResponse, operationResponse.bodyAsText);
        return Promise.reject(e);
    };
    if (!operationResponse.request.streamResponseBody && operationResponse.bodyAsText) {
        var text_1 = operationResponse.bodyAsText;
        var contentType = operationResponse.headers.get("Content-Type") || "";
        var contentComponents = !contentType ? [] : contentType.split(";").map(function (component) { return component.toLowerCase(); });
        if (contentComponents.length === 0 || contentComponents.some(function (component) { return component === "application/json" || component === "text/json"; })) {
            return new Promise(function (resolve) {
                operationResponse.parsedBody = JSON.parse(text_1);
                resolve(operationResponse);
            }).catch(errorHandler);
        }
        else if (contentComponents.some(function (component) { return component === "application/xml" || component === "text/xml"; })) {
            return xml_1.parseXML(text_1)
                .then(function (body) {
                operationResponse.parsedBody = body;
                return operationResponse;
            })
                .catch(errorHandler);
        }
    }
    return Promise.resolve(operationResponse);
}
//# sourceMappingURL=deserializationPolicy.js.map